(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("kjs", [], factory);
	else if(typeof exports === 'object')
		exports["kjs"] = factory();
	else
		root["kjs"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _pubsub = __webpack_require__(1);\n\nvar _pubsub2 = _interopRequireDefault(_pubsub);\n\nvar _nodeBinds = __webpack_require__(2);\n\nvar _nodeBinds2 = _interopRequireDefault(_nodeBinds);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nwindow.PubSub = _pubsub2.default;\nwindow.$kjsStore = function (model) {\n  kjs._states = model;\n  return new Proxy(model, {\n    get: function get(target, prop) {\n      if (target[prop]) return target[prop];\n    },\n    set: function set(target, prop, value) {\n      kjs._states = target;\n      target[prop] = typeof value === \"function\" ? value.bind(target) : value;\n      window.PubSub.publish(\"attr-\" + prop, value);\n      window.PubSub.publish(\"bind-\" + prop, value);\n      return true;\n    }\n  });\n};\n\nvar kjs = function () {\n  function kjs() {\n    _classCallCheck(this, kjs);\n\n    return this;\n  }\n\n  _createClass(kjs, [{\n    key: \"setState\",\n    value: function setState(prop, value) {\n      if (this.$store[prop] !== value) this.$store[prop] = value;\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize(view, data) {\n\n      var $ = document.querySelector.bind(document);\n      var $$ = document.querySelectorAll.bind(document);\n      var clear = function clear(node) {\n        return _nodeBinds2.default.clear(node, data);\n      };\n      Array.from($(view).querySelectorAll(\"*\")).map(function (node) {\n        return clear(node);\n      });\n    }\n  }, {\n    key: \"emitAttrs\",\n    value: function emitAttrs() {\n      var scope = this;\n      Array.from(document.querySelectorAll('[event]')).map(function (node) {\n        var eventos = node.getAttribute('event');\n        eventos = eventos.includes(',') ? eventos.split(',') : [eventos];\n        eventos.map(function (e) {\n          var _e$split$map = e.split(':').map(function (v) {\n            return v.trim();\n          }),\n              _e$split$map2 = _slicedToArray(_e$split$map, 2),\n              ev = _e$split$map2[0],\n              fn = _e$split$map2[1];\n\n          fn = kjs._states[fn] ? kjs._states[fn] : function () {\n            console.log(\"Not existing callback to event\");\n          };\n          node.addEventListener(ev, fn.bind(scope));\n        });\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var view = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"#app\";\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\n      var t0 = performance.now();\n\n      data.$app_id = Math.floor(Math.random() * 10000);\n      this.$store = window.$kjsStore(data);\n\n      this.normalize(view, data);\n\n      var t1 = performance.now();\n      this.$store.$app_time_render = parseInt(t1 - t0) + \" ms\";\n\n      this.emitAttrs();\n\n      return this;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return kjs._states;\n    }\n  }]);\n\n  return kjs;\n}();\n\nexports.default = kjs;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbGlicmFyeS5qcz84NGMwIl0sIm5hbWVzIjpbIndpbmRvdyIsIlB1YlN1YiIsIiRranNTdG9yZSIsIm1vZGVsIiwia2pzIiwiX3N0YXRlcyIsIlByb3h5IiwiZ2V0IiwidGFyZ2V0IiwicHJvcCIsInNldCIsInZhbHVlIiwiYmluZCIsInB1Ymxpc2giLCIkc3RvcmUiLCJ2aWV3IiwiZGF0YSIsIiQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCIkJCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJjbGVhciIsIm5vZGUiLCJub2RlQmluZHMiLCJBcnJheSIsImZyb20iLCJtYXAiLCJzY29wZSIsImV2ZW50b3MiLCJnZXRBdHRyaWJ1dGUiLCJpbmNsdWRlcyIsInNwbGl0IiwiZSIsInYiLCJ0cmltIiwiZXYiLCJmbiIsImNvbnNvbGUiLCJsb2ciLCJhZGRFdmVudExpc3RlbmVyIiwidDAiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIiRhcHBfaWQiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJub3JtYWxpemUiLCJ0MSIsIiRhcHBfdGltZV9yZW5kZXIiLCJwYXJzZUludCIsImVtaXRBdHRycyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7O0FBQ0E7Ozs7Ozs7O0FBRUFBLE9BQU9DLE1BQVAsR0FBZ0JBLGdCQUFoQjtBQUNBRCxPQUFPRSxTQUFQLEdBQW1CLFVBQUNDLEtBQUQsRUFBVztBQUM3QkMsTUFBSUMsT0FBSixHQUFjRixLQUFkO0FBQ0EsU0FBTyxJQUFJRyxLQUFKLENBQVVILEtBQVYsRUFBaUI7QUFDdkJJLE9BRHVCLGVBQ25CQyxNQURtQixFQUNYQyxJQURXLEVBQ047QUFDaEIsVUFBR0QsT0FBT0MsSUFBUCxDQUFILEVBQWlCLE9BQU9ELE9BQU9DLElBQVAsQ0FBUDtBQUNqQixLQUhzQjtBQUl2QkMsT0FKdUIsZUFJbkJGLE1BSm1CLEVBSVhDLElBSlcsRUFJTEUsS0FKSyxFQUlDO0FBQ3ZCUCxVQUFJQyxPQUFK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LFNBQVVGLEtBQUtSLEVBQWYsSUFBc0IsS0FBckQ7O0FBRUEsV0FBS1csU0FBTDs7QUFFRCxhQUFPLElBQVA7QUFFQTs7O3dCQTlDVTtBQUNWLGFBQU9oRCxJQUFJQyxPQUFYO0FBQ0E7Ozs7OztrQkFSa0JELEciLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBQdWJTdWIgZnJvbSBcIi4vcHVic3ViXCI7XHJcbmltcG9ydCBub2RlQmluZHMgZnJvbSBcIi4vbm9kZUJpbmRzXCI7XHJcblxyXG53aW5kb3cuUHViU3ViID0gUHViU3ViO1xyXG53aW5kb3cuJGtqc1N0b3JlID0gKG1vZGVsKSA9PiB7XHJcblx0a2pzLl9zdGF0ZXMgPSBtb2RlbDtcclxuXHRyZXR1cm4gbmV3IFByb3h5KG1vZGVsLCB7XHJcblx0XHRnZXQodGFyZ2V0LCBwcm9wKXtcclxuXHRcdFx0aWYodGFyZ2V0W3Byb3BdKSByZXR1cm4gdGFyZ2V0W3Byb3BdO1xyXG5cdFx0fSxcclxuXHRcdHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKXtcclxuXHRcdFx0a2pzLl9zdGF0ZXMgPSB0YXJnZXQ7XHJcblx0XHRcdHRhcmdldFtwcm9wXSA9IHR5cGVvZih2YWx1ZSkgPT09IFwiZnVuY3Rpb25cIiBcclxuXHRcdFx0XHRcdFx0XHQ/IHZhbHVlLmJpbmQodGFyZ2V0KVxyXG5cdFx0XHRcdFx0XHRcdDogdmFsdWU7XHJcblx0XHRcdHdpbmRvdy5QdWJTdWIucHVibGlzaChcImF0dHItXCIgKyBwcm9wLCB2YWx1ZSk7XHJcblx0XHRcdHdpbmRvdy5QdWJTdWIucHVibGlzaChcImJpbmQtXCIgKyBwcm9wLCB2YWx1ZSk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH0pXHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBranMge1xyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHN0YXRlKCl7XHJcbiAgXHRyZXR1cm4ga2pzLl9zdGF0ZXM7XHJcbiAgfVxyXG5cclxuICBzZXRTdGF0ZShwcm9wLCB2YWx1ZSl7XHJcbiAgXHRpZih0aGlzLiRzdG9yZVtwcm9wXSAhPT0gdmFsdWUpIHRoaXMuJHN0b3JlW3Byb3BdID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICBub3JtYWxpemUodmlldywgZGF0YSl7XHJcblxyXG4gIFx0Y29uc3QgJCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IuYmluZChkb2N1bWVudCk7XHJcbiAgXHRjb25zdCAkJCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwuYmluZChkb2N1bWVudCk7XHJcbiAgXHRsZXQgY2xlYXIgPSAobm9kZSkgPT4gbm9kZUJpbmRzLmNsZWFyKG5vZGUsIGRhdGEpO1xyXG4gIFx0QXJyYXkuZnJvbSgkKHZpZXcpLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpKS5tYXAoKG5vZGUpID0+IGNsZWFyKG5vZGUpKTtcclxuXHJcbiAgfVxyXG5cclxuICBlbWl0QXR0cnMoKXtcclxuICAgIGxldCBzY29wZSA9IHRoaXM7XHJcbiAgXHRBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tldmVudF0nKSkubWFwKG5vZGUgPT4ge1xyXG4gICAgICAgIGxldCBldmVudG9zID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2V2ZW50Jyk7XHJcbiAgICAgICAgZXZlbnRvcyA9IGV2ZW50b3MuaW5jbHVkZXMoJywnKSA/IGV2ZW50b3Muc3BsaXQoJywnKSA6IFtldmVudG9zXTtcclxuICAgICAgICBldmVudG9zLm1hcCgoZSkgPT4ge1xyXG4gICAgICAgICAgbGV0IFtldiwgZm5dID0gZS5zcGxpdCgnOicpLm1hcCh2ID0+IHYudHJpbSgpKTtcclxuICAgICAgICAgIGZuID0gKGtqcy5fc3RhdGVzW2ZuXSkgPyBranMuX3N0YXRlc1tmbl0gOiBmdW5jdGlvbigpeyBjb25zb2xlLmxvZyhcIk5vdCBleGlzdGluZyBjYWxsYmFjayB0byBldmVudFwiKTsgfTtcclxuICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldiwgZm4uYmluZChzY29wZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZW5kZXIodmlldyA9IFwiI2FwcFwiLCBkYXRhID0ge30pe1xyXG5cclxuICAgIHZhciB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG5cclxuICAgIGRhdGEuJGFwcF9pZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcclxuICAgIHRoaXMuJHN0b3JlID0gd2luZG93LiRranNTdG9yZShkYXRhKTtcclxuXHJcbiAgXHR0aGlzLm5vcm1hbGl6ZSh2aWV3LCBkYXRhKTtcclxuXHJcbiAgICB2YXIgdDEgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIHRoaXMuJHN0b3JlLiRhcHBfdGltZV9yZW5kZXIgPSBwYXJzZUludCgodDEgLSB0MCkpICsgXCIgbXNcIjtcclxuXHJcbiAgICB0aGlzLmVtaXRBdHRycygpO1xyXG5cclxuICBcdHJldHVybiB0aGlzO1xyXG5cclxuICB9XHJcblxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9saWJyYXJ5LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar PubSub = function () {\n  function PubSub() {\n    _classCallCheck(this, PubSub);\n\n    this.topics = {};\n  }\n\n  _createClass(PubSub, [{\n    key: 'on',\n    value: function on(topic, listener) {\n\n      if (!this.topics[topic]) this.topics[topic] = { queue: [] };\n      var index = this.topics[topic].queue.push(listener) - 1;\n      return function (topic, index) {\n        var context = {\n          remove: function remove() {\n            delete this.topics[topic].queue[index];\n          }\n        };\n        return Object.assign(this, context);\n      }.bind(this)(topic, index);\n    }\n  }, {\n    key: 'publish',\n    value: function publish(topic, info) {\n      if (!this.topics[topic] || !this.topics[topic].queue.length) return;\n      var items = this.topics[topic].queue;\n      for (var i = 0, len = items.length; i < len; i++) {\n        if (typeof items[i] === 'function') items[i](info || {});\n      }\n    }\n  }]);\n\n  return PubSub;\n}();\n\n;\n\nexports.default = new PubSub();\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcHVic3ViLmpzP2QyNWUiXSwibmFtZXMiOlsiUHViU3ViIiwidG9waWNzIiwidG9waWMiLCJsaXN0ZW5lciIsInF1ZXVlIiwiaW5kZXgiLCJwdXNoIiwiY29udGV4dCIsInJlbW92ZSIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJpbmZvIiwibGVuZ3RoIiwiaXRlbXMiLCJpIiwibGVuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0lBQU1BLE07QUFFTCxvQkFBYTtBQUFBOztBQUNaLFNBQUtDLE1BQUwsR0FBYyxFQUFkO0FBQ0E7Ozs7dUJBRUVDLEssRUFBT0MsUSxFQUFVOztBQUVmLFVBQUcsQ0FBQyxLQUFLRixNQUFMLENBQVlDLEtBQVosQ0FBSixFQUF3QixLQUFLRCxNQUFMLENBQVlDLEtBQVosSUFBcUIsRUFBRUUsT0FBTyxFQUFULEVBQXJCO0FBQ3hCLFVBQUlDLFFBQVEsS0FBS0osTUFBTCxDQUFZQyxLQUFaLEVBQW1CRSxLQUFuQixDQUF5QkUsSUFBekIsQ0FBOEJILFFBQTlCLElBQTBDLENBQXREO0FBQ0EsYUFBUSxVQUFTRCxLQUFULEVBQWdCRyxLQUFoQixFQUF1QjtBQUM5QixZQUFNRSxVQUFVO0FBQ2JDLGtCQUFRLGtCQUFXO0FBQ2pCLG1CQUFPLEtBQUtQLE1BQUwsQ0FBWUMsS0FBWixFQUFtQkUsS0FBbkIsQ0FBeUJDLEtBQXpCLENBQVA7QUFDRDtBQUhZLFNBQWhCO0FBS0MsZUFBT0ksT0FBT0MsTUFBUCxDQUFjLElBQWQsRUFBb0JILE9BQXBCLENBQVA7QUFDRCxPQVBNLENBT0pJLElBUEksQ0FPQyxJQVBELEVBT09ULEtBUFAsRUFPY0csS0FQZCxDQUFQO0FBU0Q7Ozs0QkFFT0gsSyxFQUFPVSxJLEVBQU07QUFDbkIsVUFBRyxDQUFDLEtBQUtYLE1BQUwsQ0FBWUMsS0FBWixDQUFELElBQXVCLENBQUMsS0FBS0QsTUFBTCxDQUFZQyxLQUFaLEVBQW1CRSxLQUFuQixDQUF5QlMsTUFBcEQsRUFBNEQ7QUFDNUQsVUFBSUMsUUFBUSxLQUFLYixNQUFMLENBQVlDLEtBQVosRUFBbUJFLEtBQS9CO0FBQ0EsV0FBSSxJQUFJVyxJQUFJLENBQVIsRUFBV0MsTUFBTUYsTUFBTUQsTUFBM0IsRUFBbUNFLElBQUlDLEdBQXZDLEVBQTRDRCxHQUE1QyxFQUFpRDtBQUMvQyxZQUFHLE9BQU9ELE1BQU1DLENBQU4sQ0FBUCxLQUFvQixVQUF2QixFQUFtQ0QsTUFBTUMsQ0FBTixFQUFTSCxRQUFRLEVBQWpCO0FBQ3BDO0FBQ0Y7Ozs7OztBQUVKOztrQkFFYyxJQUFJWixNQUFKLEUiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImNsYXNzIFB1YlN1YiB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHR0aGlzLnRvcGljcyA9IHt9O1xyXG5cdH1cclxuXHJcblx0b24odG9waWMsIGxpc3RlbmVyKSB7XHJcblxyXG4gICAgICBpZighdGhpcy50b3BpY3NbdG9waWNdKSB0aGlzLnRvcGljc1t0b3BpY10gPSB7IHF1ZXVlOiBbXSB9O1xyXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLnRvcGljc1t0b3BpY10ucXVldWUucHVzaChsaXN0ZW5lcikgLSAxO1xyXG4gICAgICByZXR1cm4gKGZ1bmN0aW9uKHRvcGljLCBpbmRleCkge1xyXG4gICAgICBcdGNvbnN0IGNvbnRleHQgPSB7XHJcbiAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy50b3BpY3NbdG9waWNdLnF1ZXVlW2luZGV4XTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRoaXMsIGNvbnRleHQpO1xyXG4gICAgICB9KS5iaW5kKHRoaXMpKHRvcGljLCBpbmRleCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1Ymxpc2godG9waWMsIGluZm8pIHtcclxuICAgICAgaWYoIXRoaXMudG9waWNzW3RvcGljXSB8fCAhdGhpcy50b3BpY3NbdG9waWNdLnF1ZXVlLmxlbmd0aCkgcmV0dXJuO1xyXG4gICAgICBsZXQgaXRlbXMgPSB0aGlzLnRvcGljc1t0b3BpY10ucXVldWU7XHJcbiAgICAgIGZvcihsZXQgaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgaWYodHlwZW9mIGl0ZW1zW2ldID09PSAnZnVuY3Rpb24nKSBpdGVtc1tpXShpbmZvIHx8IHt9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IG5ldyBQdWJTdWIoKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL3B1YnN1Yi5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _render3 = __webpack_require__(3);\n\nvar Template = _interopRequireWildcard(_render3);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar nodeBinds = function () {\n\tfunction nodeBinds() {\n\t\t_classCallCheck(this, nodeBinds);\n\t}\n\n\t_createClass(nodeBinds, [{\n\t\tkey: 'attributes',\n\t\tvalue: function attributes(node) {\n\t\t\tvar attrs = new Object(node.attributes);\n\t\t\tvar attrsn = {};\n\t\t\tObject.keys(attrs).map(function (k) {\n\t\t\t\tattrsn[attrs[k]['name']] = attrs[k]['value'];\n\t\t\t});\n\t\t\treturn attrsn;\n\t\t}\n\t}, {\n\t\tkey: 'dataExists',\n\t\tvalue: function dataExists(template, data) {\n\t\t\tvar key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n\t\t\ttemplate = template.trim();\n\t\t\tvar vd = [];\n\t\t\tvar g = Object.keys(data).map(function (v) {\n\t\t\t\tif (template.includes(v)) {\n\t\t\t\t\tif (key !== null) {\n\t\t\t\t\t\tvd.push([key, v]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvd.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn vd;\n\t\t}\n\t}, {\n\t\tkey: 'clear',\n\t\tvalue: function clear(node, data) {\n\t\t\tvar new_node = node.cloneNode(true);\n\t\t\tvar pattern = /<(.*?)>(.*?)<\\/(.*?)>/g;\n\t\t\tnew_node.innerHTML = new_node.innerHTML.replace(pattern, function () {\n\t\t\t\tfor (var _len = arguments.length, a = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\t\ta[_key] = arguments[_key];\n\t\t\t\t}\n\n\t\t\t\tvar context = a[2];\n\n\t\t\t\tnew_node.innerText = new_node.innerText.replace(new RegExp(context, 'gi'), '');\n\t\t\t\treturn '';\n\t\t\t});\n\t\t\tthis.binds(new_node, data, node);\n\t\t}\n\t}, {\n\t\tkey: 'binds',\n\t\tvalue: function binds(node, data, nodeOrigin) {\n\t\t\tvar _this = this;\n\n\t\t\tvar observerAttr = function observerAttr(attr, key, oldValue) {\n\n\t\t\t\tvar fn = function (value) {\n\t\t\t\t\tvar render = oldValue.includes(\"[{\") && oldValue.includes(\"}]\") ? Template.interpolateAttr : Template.interpolate;\n\t\t\t\t\tvar r = render(oldValue, _defineProperty({}, attr, value));\n\t\t\t\t\tnodeOrigin.setAttribute(key, r);\n\t\t\t\t}.bind(_this);\n\n\t\t\t\tfn(data[attr]);\n\t\t\t\twindow.PubSub.on(\"attr-\" + attr, fn);\n\t\t\t};\n\n\t\t\tvar observerBind = function observerBind(bind) {\n\n\t\t\t\tvar fn = function (value) {\n\t\t\t\t\tvar render = node.innerText.includes(\"[{\") && node.innerText.includes(\"}]\") ? Template.interpolateAttr : Template.interpolate;\n\t\t\t\t\tnodeOrigin.innerText = render(node.innerText, _defineProperty({}, bind, value));\n\t\t\t\t}.bind(_this);\n\n\t\t\t\tfn(data[bind]);\n\t\t\t\twindow.PubSub.on(\"bind-\" + bind, fn);\n\t\t\t};\n\n\t\t\tvar bnds = [];\n\t\t\tvar values = this.dataExists(node.innerText, data);\n\t\t\tvar attrs = this.attributes(node);\n\n\t\t\tObject.keys(attrs).map(function (key) {\n\t\t\t\tvar att = attrs[key];\n\t\t\t\tvar find = this.dataExists(att, data, key);\n\t\t\t\tif (Array.isArray(find) && find.length > 0) {\n\t\t\t\t\tfind.map(function (a) {\n\t\t\t\t\t\treturn observerAttr(a[1], a[0], att);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}.bind(this));\n\n\t\t\tvalues.map(function (v) {\n\t\t\t\treturn observerBind(v);\n\t\t\t});\n\t\t}\n\t}]);\n\n\treturn nodeBinds;\n}();\n\n;\n\nexports.default = new nodeBinds();\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbm9kZUJpbmRzLmpzPzRjOTYiXSwibmFtZXMiOlsiVGVtcGxhdGUiLCJub2RlQmluZHMiLCJub2RlIiwiYXR0cnMiLCJPYmplY3QiLCJhdHRyaWJ1dGVzIiwiYXR0cnNuIiwia2V5cyIsIm1hcCIsImsiLCJ0ZW1wbGF0ZSIsImRhdGEiLCJrZXkiLCJ0cmltIiwidmQiLCJnIiwidiIsImluY2x1ZGVzIiwicHVzaCIsIm5ld19ub2RlIiwiY2xvbmVOb2RlIiwicGF0dGVybiIsImlubmVySFRNTCIsInJlcGxhY2UiLCJhIiwiY29udGV4dCIsImlubmVyVGV4dCIsIlJlZ0V4cCIsImJpbmRzIiwibm9kZU9yaWdpbiIsIm9ic2VydmVyQXR0ciIsImF0dHIiLCJvbGRWYWx1ZSIsImZuIiwidmFsdWUiLCJyZW5kZXIiLCJpbnRlcnBvbGF0ZUF0dHIiLCJpbnRlcnBvbGF0ZSIsInIiLCJzZXRBdHRyaWJ1dGUiLCJiaW5kIiwid2luZG93IiwiUHViU3ViIiwib24iLCJvYnNlcnZlckJpbmQiLCJibmRzIiwidmFsdWVzIiwiZGF0YUV4aXN0cyIsImF0dCIsImZpbmQiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7O0lBQVlBLFE7Ozs7Ozs7O0lBRU5DLFM7QUFFTCxzQkFBYTtBQUFBO0FBQUU7Ozs7NkJBRUpDLEksRUFBSztBQUNmLE9BQUlDLFFBQVEsSUFBSUMsTUFBSixDQUFXRixLQUFLRyxVQUFoQixDQUFaO0FBQ0EsT0FBSUMsU0FBUyxFQUFiO0FBQ0FGLFVBQU9HLElBQVAsQ0FBWUosS0FBWixFQUFtQkssR0FBbkIsQ0FBdUIsVUFBQ0MsQ0FBRCxFQUFPO0FBQzdCSCxXQUFPSCxNQUFNTSxDQUFOLEVBQVMsTUFBVCxDQUFQLElBQTJCTixNQUFNTSxDQUFOLEVBQVMsT0FBVCxDQUEzQjtBQUNBLElBRkQ7QUFHQSxVQUFPSCxNQUFQO0FBQ0E7Ozs2QkFFVUksUSxFQUFVQyxJLEVBQWlC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QUFoQyxDQUFiO0FBQ0EsT0FBSVIsUUFBUSxLQUFLRSxVQUFMLENBQWdCSCxJQUFoQixDQUFaOztBQUVBRSxVQUFPRyxJQUFQLENBQVlKLEtBQVosRUFBbUJLLEdBQW5CLENBQXVCLFVBQVNJLEdBQVQsRUFBYTtBQUNuQyxRQUFJb0MsTUFBTTdDLE1BQU1TLEdBQU4sQ0FBVjtBQUNBLFFBQUlxQyxPQUFPLEtBQUtGLFVBQUwsQ0FBZ0JDLEdBQWhCLEVBQXFCckMsSUFBckIsRUFBMkJDLEdBQTNCLENBQVg7QUFDQSxRQUFHc0MsTUFBTUMsT0FBTixDQUFjRixJQUFkLEtBQXVCQSxLQUFLRyxNQUFMLEdBQWMsQ0FBeEMsRUFBMEM7QUFDekNILFVBQUt6QyxHQUFMLENBQVMsVUFBQ2dCLENBQUQ7QUFBQSxhQUFPTSxhQUFhTixFQUFFLENBQUYsQ0FBYixFQUFtQkEsRUFBRSxDQUFGLENBQW5CLEVBQXlCd0IsR0FBekIsQ0FBUDtBQUFBLE1BQVQ7QUFDQTtBQUNELElBTnNCLENBTXJCUixJQU5xQixDQU1oQixJQU5nQixDQUF2Qjs7QUFRQU0sVUFBT3RDLEdBQVAsQ0FBVyxVQUFDUSxDQUFEO0FBQUEsV0FBTzRCLGFBQWE1QixDQUFiLENBQVA7QUFBQSxJQUFYO0FBRUE7Ozs7OztBQUVEOztrQkFFYyxJQUFJZixTQUFKLEUiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRlbXBsYXRlIGZyb20gJy4vcmVuZGVyJztcclxuXHJcbmNsYXNzIG5vZGVCaW5kcyB7XHJcblxyXG5cdGNvbnN0cnVjdG9yKCl7fVxyXG5cclxuXHRhdHRyaWJ1dGVzKG5vZGUpe1xyXG5cdFx0dmFyIGF0dHJzID0gbmV3IE9iamVjdChub2RlLmF0dHJpYnV0ZXMpO1xyXG5cdFx0dmFyIGF0dHJzbiA9IHt9O1xyXG5cdFx0T2JqZWN0LmtleXMoYXR0cnMpLm1hcCgoaykgPT4ge1xyXG5cdFx0XHRhdHRyc25bYXR0cnNba11bJ25hbWUnXV0gPSBhdHRyc1trXVsndmFsdWUnXTtcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIGF0dHJzbjtcclxuXHR9XHJcblxyXG5cdGRhdGFFeGlzdHModGVtcGxhdGUsIGRhdGEsIGtleSA9IG51bGwpe1xyXG5cdFx0dGVtcGxhdGUgPSB0ZW1wbGF0ZS50cmltKCk7XHJcblx0XHRsZXQgdmQgPSBbXTtcclxuXHRcdGxldCBnID0gT2JqZWN0LmtleXMoZGF0YSkubWFwKCh2KSA9PiB7XHJcblx0XHRcdGlmKHRlbXBsYXRlLmluY2x1ZGVzKHYpKXtcclxuXHRcdFx0XHRpZihrZXkgIT09IG51bGwpe1xyXG5cdFx0XHRcdFx0dmQucHVzaChba2V5LCB2XSk7XHJcblx0XHRcdFx0fWVsc2V7IFxyXG5cdFx0XHRcdFx0dmQucHVzaCh2KTsgXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiB2ZDtcclxuXHR9XHJcblxyXG5cdGNsZWFyKG5vZGUsIGRhdGEpe1xyXG5cdFx0bGV0IG5ld19ub2RlID0gbm9kZS5jbG9uZU5vZGUodHJ1ZSk7XHJcblx0XHRsZXQgcGF0dGVybiA9IC88KC4qPyk+KC4qPyk8XFwvKC4qPyk+L2c7XHJcblx0XHRuZXdfbm9kZS5pbm5lckhUTUwgPSBuZXdfbm9kZS5pbm5lckhUTUwucmVwbGFjZShwYXR0ZXJuLCAoLi4uYSkgPT4ge1xyXG5cdFx0XHRsZXQgWywsIGNvbnRleHRdID0gYTtcclxuXHRcdFx0bmV3X25vZGUuaW5uZXJUZXh0ID0gbmV3X25vZGUuaW5uZXJUZXh0XHJcblx0XHRcdC5yZXBsYWNlKG5ldyBSZWdFeHAoY29udGV4dCwgJ2dpJyksICcnKTtcclxuXHRcdFx0cmV0dXJuICcnO1xyXG5cdFx0fSk7XHRcclxuXHRcdHRoaXMuYmluZHMobmV3X25vZGUsIGRhdGEsIG5vZGUpO1xyXG5cdH1cclxuXHJcblx0YmluZHMobm9kZSwgZGF0YSwgbm9kZU9yaWdpbil7XHJcblxyXG5cdFx0bGV0IG9ic2VydmVyQXR0ciA9IChhdHRyLCBrZXksIG9sZFZhbHVlKSA9PiB7XHJcblxyXG5cdFx0XHRsZXQgZm4gPSBmdW5jdGlvbih2YWx1ZSl7XHJcblx0XHRcdFx0bGV0IHJlbmRlciA9IG9sZFZhbHVlLmluY2x1ZGVzKFwiW3tcIikgJiYgb2xkVmFsdWUuaW5jbHVkZXMoXCJ9XVwiKSA/XHJcblx0XHRcdFx0XHRUZW1wbGF0ZS5pbnRlcnBvbGF0ZUF0dHIgOiBUZW1wbGF0ZS5pbnRlcnBvbGF0ZTtcclxuXHRcdFx0XHRcdGxldCByID0gcmVuZGVyKG9sZFZhbHVlLCB7XHJcblx0XHRcdFx0XHRcdFthdHRyXTogdmFsdWVcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0bm9kZU9yaWdpbi5zZXRBdHRyaWJ1dGUoa2V5LCByKTtcclxuXHRcdFx0fS5iaW5kKHRoaXMpO1xyXG5cclxuXHRcdFx0Zm4oZGF0YVthdHRyXSk7XHJcblx0XHRcdHdpbmRvdy5QdWJTdWIub24oXCJhdHRyLVwiICsgYXR0ciwgZm4pO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0bGV0IG9ic2VydmVyQmluZCA9IChiaW5kKSA9PiB7XHJcblxyXG5cdFx0XHRsZXQgZm4gPSBmdW5jdGlvbih2YWx1ZSl7XHJcblx0XHRcdFx0bGV0IHJlbmRlciA9IG5vZGUuaW5uZXJUZXh0LmluY2x1ZGVzKFwiW3tcIikgJiYgbm9kZS5pbm5lclRleHQuaW5jbHVkZXMoXCJ9XVwiKSA/XHJcblx0XHRcdFx0XHRUZW1wbGF0ZS5pbnRlcnBvbGF0ZUF0dHIgOiBUZW1wbGF0ZS5pbnRlcnBvbGF0ZTtcclxuXHRcdFx0XHRcdG5vZGVPcmlnaW4uaW5uZXJUZXh0ID0gcmVuZGVyKG5vZGUuaW5uZXJUZXh0LCB7XHJcblx0XHRcdFx0XHRcdFtiaW5kXTogdmFsdWVcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHR9LmJpbmQodGhpcyk7XHJcblxyXG5cdFx0XHRmbihkYXRhW2JpbmRdKTtcclxuXHRcdFx0d2luZG93LlB1YlN1Yi5vbihcImJpbmQtXCIgKyBiaW5kLCBmbik7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0XHRsZXQgYm5kcyA9IFtdO1xyXG5cdFx0bGV0IHZhbHVlcyA9IHRoaXMuZGF0YUV4aXN0cyhub2RlLmlubmVyVGV4dCwgZGF0YSk7XHJcblx0XHRsZXQgYXR0cnMgPSB0aGlzLmF0dHJpYnV0ZXMobm9kZSk7XHJcblxyXG5cdFx0T2JqZWN0LmtleXMoYXR0cnMpLm1hcChmdW5jdGlvbihrZXkpe1xyXG5cdFx0XHRsZXQgYXR0ID0gYXR0cnNba2V5XTtcclxuXHRcdFx0bGV0IGZpbmQgPSB0aGlzLmRhdGFFeGlzdHMoYXR0LCBkYXRhLCBrZXkpO1xyXG5cdFx0XHRpZihBcnJheS5pc0FycmF5KGZpbmQpICYmIGZpbmQubGVuZ3RoID4gMCl7XHJcblx0XHRcdFx0ZmluZC5tYXAoKGEpID0+IG9ic2VydmVyQXR0cihhWzFdLCBhWzBdLCBhdHQpKTtcclxuXHRcdFx0fVxyXG5cdFx0fS5iaW5kKHRoaXMpKTtcclxuXHJcblx0XHR2YWx1ZXMubWFwKCh2KSA9PiBvYnNlcnZlckJpbmQodikpO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgbmV3IG5vZGVCaW5kcztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL25vZGVCaW5kcy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.interpolate = interpolate;\nexports.interpolateAttr = interpolateAttr;\n\nvar _mustache = __webpack_require__(4);\n\nvar _mustache2 = _interopRequireDefault(_mustache);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction interpolate(tpl, d) {\n\n\tvar data = kjs._states || d;\n\treturn _mustache2.default.render(tpl, data);\n}\n\nfunction interpolateAttr(tpl, d) {\n\n\tvar data = kjs._states || d;\n\tvar pattern = /\\[\\{\\s?(.*)\\s?\\}\\]/gim;\n\tvar ntpl = tpl.replace(pattern, function (repl, arg) {\n\t\tObject.keys(data).map(function (k) {\n\t\t\tif (arg.includes('data.' + k)) return;\n\t\t\targ = arg.replace(new RegExp(k, 'gim'), 'data.' + k);\n\t\t});\n\t\treturn '${' + arg + '}';\n\t});\n\n\treturn new Function('data', 'return `' + ntpl + '`;')(data);\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcmVuZGVyLmpzPzQ4NTgiXSwibmFtZXMiOlsiaW50ZXJwb2xhdGUiLCJpbnRlcnBvbGF0ZUF0dHIiLCJ0cGwiLCJkIiwiZGF0YSIsImtqcyIsIl9zdGF0ZXMiLCJNdXN0YWNoZSIsInJlbmRlciIsInBhdHRlcm4iLCJudHBsIiwicmVwbGFjZSIsInJlcGwiLCJhcmciLCJPYmplY3QiLCJrZXlzIiwibWFwIiwiayIsImluY2x1ZGVzIiwiUmVnRXhwIiwiRnVuY3Rpb24iXSwibWFwcGluZ3MiOiI7Ozs7O1FBRWdCQSxXLEdBQUFBLFc7UUFPQUMsZSxHQUFBQSxlOztBQVRoQjs7Ozs7O0FBRU8sU0FBU0QsV0FBVCxDQUFxQkUsR0FBckIsRUFBMEJDLENBQTFCLEVBQTRCOztBQUVsQyxLQUFJQyxPQUFPQyxJQUFJQyxPQUFKLElBQWVILENBQTFCO0FBQ0EsUUFBT0ksbUJBQVNDLE1BQVQsQ0FBZ0JOLEdBQWhCLEVBQXFCRSxJQUFyQixDQUFQO0FBRUE7O0FBRU0sU0FBU0gsZUFBVCxDQUF5QkMsR0FBekIsRUFBOEJDLENBQTlCLEVBQWdDOztBQUV0QyxLQUFJQyxPQUFPQyxJQUFJQyxPQUFKLElBQWVILENBQTFCO0FBQ0EsS0FBSU0sVUFBVSx1QkFBZDtBQUNBLEtBQUlDLE9BQU9SLElBQUlTLE9BQUosQ0FBWUYsT0FBWixFQUFxQixVQUFDRyxJQUFELEVBQU9DLEdBQVAsRUFBZTtBQUM5Q0MsU0FBT0MsSUFBUCxDQUFZWCxJQUFaLEVBQWtCWSxHQUFsQixDQUFzQixVQUFDQyxDQUFELEVBQU87QUFDNUIsT0FBR0osSUFBSUssUUFBSixDQUFhLFVBQVVELENBQXZCLENBQUgsRUFBOEI7QUFDOUJKLFNBQU1BLElBQUlGLE9BQUosQ0FBWSxJQUFJUSxNQUFKLENBQVdGLENBQVgsRUFBYyxLQUFkLENBQVosRUFBa0MsVUFBVUEsQ0FBNUMsQ0FBTjtBQUNBLEdBSEQ7QUFJQSxTQUFPLE9BQU9KLEdBQVAsR0FBYSxHQUFwQjtBQUNBLEVBTlUsQ0FBWDs7QUFRQSxRQUFPLElBQUlPLFFBQUosQ0FBYSxNQUFiLEVBQXFCLGFBQVdWLElBQVgsR0FBZ0IsSUFBckMsRUFBMkNOLElBQTNDLENBQVA7QUFFQSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE11c3RhY2hlIGZyb20gJ211c3RhY2hlJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnBvbGF0ZSh0cGwsIGQpe1xyXG5cclxuXHRsZXQgZGF0YSA9IGtqcy5fc3RhdGVzIHx8IGQ7XHJcblx0cmV0dXJuIE11c3RhY2hlLnJlbmRlcih0cGwsIGRhdGEpO1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGludGVycG9sYXRlQXR0cih0cGwsIGQpe1xyXG5cclxuXHRsZXQgZGF0YSA9IGtqcy5fc3RhdGVzIHx8IGQ7XHJcblx0bGV0IHBhdHRlcm4gPSAvXFxbXFx7XFxzPyguKilcXHM/XFx9XFxdL2dpbTtcclxuXHRsZXQgbnRwbCA9IHRwbC5yZXBsYWNlKHBhdHRlcm4sIChyZXBsLCBhcmcpID0+IHtcclxuXHRcdE9iamVjdC5rZXlzKGRhdGEpLm1hcCgoaykgPT4ge1xyXG5cdFx0XHRpZihhcmcuaW5jbHVkZXMoJ2RhdGEuJyArIGspKSByZXR1cm47XHJcblx0XHRcdGFyZyA9IGFyZy5yZXBsYWNlKG5ldyBSZWdFeHAoaywgJ2dpbScpLCAnZGF0YS4nICsgayk7XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiAnJHsnICsgYXJnICsgJ30nO1xyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gbmV3IEZ1bmN0aW9uKCdkYXRhJywgJ3JldHVybiBgJytudHBsKydgOycpKGRhdGEpO1xyXG5cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvcmVuZGVyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false Mustache: true*/\n\n(function defineMustache (global, factory) {\n  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {\n    factory(exports); // CommonJS\n  } else if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // AMD\n  } else {\n    global.Mustache = {};\n    factory(global.Mustache); // script, wsh, asp\n  }\n}(this, function mustacheFactory (mustache) {\n\n  var objectToString = Object.prototype.toString;\n  var isArray = Array.isArray || function isArrayPolyfill (object) {\n    return objectToString.call(object) === '[object Array]';\n  };\n\n  function isFunction (object) {\n    return typeof object === 'function';\n  }\n\n  /**\n   * More correct typeof string handling array\n   * which normally returns typeof 'object'\n   */\n  function typeStr (obj) {\n    return isArray(obj) ? 'array' : typeof obj;\n  }\n\n  function escapeRegExp (string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n  }\n\n  /**\n   * Null safe way of checking whether or not an object,\n   * including its prototype, has a given property\n   */\n  function hasProperty (obj, propName) {\n    return obj != null && typeof obj === 'object' && (propName in obj);\n  }\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  var regExpTest = RegExp.prototype.test;\n  function testRegExp (re, string) {\n    return regExpTest.call(re, string);\n  }\n\n  var nonSpaceRe = /\\S/;\n  function isWhitespace (string) {\n    return !testRegExp(nonSpaceRe, string);\n  }\n\n  var entityMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '/': '&#x2F;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n  };\n\n  function escapeHtml (string) {\n    return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap (s) {\n      return entityMap[s];\n    });\n  }\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var equalsRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  /**\n   * Breaks up the given `template` string into a tree of tokens. If the `tags`\n   * argument is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n   * course, the default is to use mustaches (i.e. mustache.tags).\n   *\n   * A token is an array with at least 4 elements. The first element is the\n   * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n   * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n   * all text that appears outside a symbol this element is \"text\".\n   *\n   * The second element of a token is its \"value\". For mustache tags this is\n   * whatever else was inside the tag besides the opening symbol. For text tokens\n   * this is the text itself.\n   *\n   * The third and fourth elements of the token are the start and end indices,\n   * respectively, of the token in the original template.\n   *\n   * Tokens that are the root node of a subtree contain two more elements: 1) an\n   * array of tokens in the subtree and 2) the index in the original template at\n   * which the closing tag for that section begins.\n   */\n  function parseTemplate (template, tags) {\n    if (!template)\n      return [];\n\n    var sections = [];     // Stack to hold section tokens\n    var tokens = [];       // Buffer to hold the tokens\n    var spaces = [];       // Indices of whitespace tokens on the current line\n    var hasTag = false;    // Is there a {{tag}} on the current line?\n    var nonSpace = false;  // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace () {\n      if (hasTag && !nonSpace) {\n        while (spaces.length)\n          delete tokens[spaces.pop()];\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var openingTagRe, closingTagRe, closingCurlyRe;\n    function compileTags (tagsToCompile) {\n      if (typeof tagsToCompile === 'string')\n        tagsToCompile = tagsToCompile.split(spaceRe, 2);\n\n      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\n        throw new Error('Invalid tags: ' + tagsToCompile);\n\n      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\n      closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\n      closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\n    }\n\n    compileTags(tags || mustache.tags);\n\n    var scanner = new Scanner(template);\n\n    var start, type, value, chr, token, openSection;\n    while (!scanner.eos()) {\n      start = scanner.pos;\n\n      // Match any text between tags.\n      value = scanner.scanUntil(openingTagRe);\n\n      if (value) {\n        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push([ 'text', chr, start, start + 1 ]);\n          start += 1;\n\n          // Check for whitespace on the current line.\n          if (chr === '\\n')\n            stripSpace();\n        }\n      }\n\n      // Match the opening tag.\n      if (!scanner.scan(openingTagRe))\n        break;\n\n      hasTag = true;\n\n      // Get the tag type.\n      type = scanner.scan(tagRe) || 'name';\n      scanner.scan(whiteRe);\n\n      // Get the tag value.\n      if (type === '=') {\n        value = scanner.scanUntil(equalsRe);\n        scanner.scan(equalsRe);\n        scanner.scanUntil(closingTagRe);\n      } else if (type === '{') {\n        value = scanner.scanUntil(closingCurlyRe);\n        scanner.scan(curlyRe);\n        scanner.scanUntil(closingTagRe);\n        type = '&';\n      } else {\n        value = scanner.scanUntil(closingTagRe);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(closingTagRe))\n        throw new Error('Unclosed tag at ' + scanner.pos);\n\n      token = [ type, value, start, scanner.pos ];\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === '/') {\n        // Check section nesting.\n        openSection = sections.pop();\n\n        if (!openSection)\n          throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n        if (openSection[1] !== value)\n          throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n      } else if (type === 'name' || type === '{' || type === '&') {\n        nonSpace = true;\n      } else if (type === '=') {\n        // Set the tags for the next time around.\n        compileTags(value);\n      }\n    }\n\n    // Make sure there are no open sections when we're done.\n    openSection = sections.pop();\n\n    if (openSection)\n      throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n    return nestTokens(squashTokens(tokens));\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens (tokens) {\n    var squashedTokens = [];\n\n    var token, lastToken;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      if (token) {\n        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n          lastToken[1] += token[1];\n          lastToken[3] = token[3];\n        } else {\n          squashedTokens.push(token);\n          lastToken = token;\n        }\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n  function nestTokens (tokens) {\n    var nestedTokens = [];\n    var collector = nestedTokens;\n    var sections = [];\n\n    var token, section;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n        case '#':\n        case '^':\n          collector.push(token);\n          sections.push(token);\n          collector = token[4] = [];\n          break;\n        case '/':\n          section = sections.pop();\n          section[5] = token[2];\n          collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n          break;\n        default:\n          collector.push(token);\n      }\n    }\n\n    return nestedTokens;\n  }\n\n  /**\n   * A simple string scanner that is used by the template parser to find\n   * tokens in template strings.\n   */\n  function Scanner (string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function eos () {\n    return this.tail === '';\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function scan (re) {\n    var match = this.tail.match(re);\n\n    if (!match || match.index !== 0)\n      return '';\n\n    var string = match[0];\n\n    this.tail = this.tail.substring(string.length);\n    this.pos += string.length;\n\n    return string;\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function scanUntil (re) {\n    var index = this.tail.search(re), match;\n\n    switch (index) {\n      case -1:\n        match = this.tail;\n        this.tail = '';\n        break;\n      case 0:\n        match = '';\n        break;\n      default:\n        match = this.tail.substring(0, index);\n        this.tail = this.tail.substring(index);\n    }\n\n    this.pos += match.length;\n\n    return match;\n  };\n\n  /**\n   * Represents a rendering context by wrapping a view object and\n   * maintaining a reference to the parent context.\n   */\n  function Context (view, parentContext) {\n    this.view = view;\n    this.cache = { '.': this.view };\n    this.parent = parentContext;\n  }\n\n  /**\n   * Creates a new context using the given view with this context\n   * as the parent.\n   */\n  Context.prototype.push = function push (view) {\n    return new Context(view, this);\n  };\n\n  /**\n   * Returns the value of the given name in this context, traversing\n   * up the context hierarchy if the value is absent in this context's view.\n   */\n  Context.prototype.lookup = function lookup (name) {\n    var cache = this.cache;\n\n    var value;\n    if (cache.hasOwnProperty(name)) {\n      value = cache[name];\n    } else {\n      var context = this, names, index, lookupHit = false;\n\n      while (context) {\n        if (name.indexOf('.') > 0) {\n          value = context.view;\n          names = name.split('.');\n          index = 0;\n\n          /**\n           * Using the dot notion path in `name`, we descend through the\n           * nested objects.\n           *\n           * To be certain that the lookup has been successful, we have to\n           * check if the last object in the path actually has the property\n           * we are looking for. We store the result in `lookupHit`.\n           *\n           * This is specially necessary for when the value has been set to\n           * `undefined` and we want to avoid looking up parent contexts.\n           **/\n          while (value != null && index < names.length) {\n            if (index === names.length - 1)\n              lookupHit = hasProperty(value, names[index]);\n\n            value = value[names[index++]];\n          }\n        } else {\n          value = context.view[name];\n          lookupHit = hasProperty(context.view, name);\n        }\n\n        if (lookupHit)\n          break;\n\n        context = context.parent;\n      }\n\n      cache[name] = value;\n    }\n\n    if (isFunction(value))\n      value = value.call(this.view);\n\n    return value;\n  };\n\n  /**\n   * A Writer knows how to take a stream of tokens and render them to a\n   * string, given a context. It also maintains a cache of templates to\n   * avoid the need to parse the same template twice.\n   */\n  function Writer () {\n    this.cache = {};\n  }\n\n  /**\n   * Clears all cached templates in this writer.\n   */\n  Writer.prototype.clearCache = function clearCache () {\n    this.cache = {};\n  };\n\n  /**\n   * Parses and caches the given `template` and returns the array of tokens\n   * that is generated from the parse.\n   */\n  Writer.prototype.parse = function parse (template, tags) {\n    var cache = this.cache;\n    var tokens = cache[template];\n\n    if (tokens == null)\n      tokens = cache[template] = parseTemplate(template, tags);\n\n    return tokens;\n  };\n\n  /**\n   * High-level method that is used to render the given `template` with\n   * the given `view`.\n   *\n   * The optional `partials` argument may be an object that contains the\n   * names and templates of partials that are used in the template. It may\n   * also be a function that is used to load partial templates on the fly\n   * that takes a single argument: the name of the partial.\n   */\n  Writer.prototype.render = function render (template, view, partials) {\n    var tokens = this.parse(template);\n    var context = (view instanceof Context) ? view : new Context(view);\n    return this.renderTokens(tokens, context, partials, template);\n  };\n\n  /**\n   * Low-level method that renders the given array of `tokens` using\n   * the given `context` and `partials`.\n   *\n   * Note: The `originalTemplate` is only ever used to extract the portion\n   * of the original template that was contained in a higher-order section.\n   * If the template doesn't use higher-order sections, this argument may\n   * be omitted.\n   */\n  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate) {\n    var buffer = '';\n\n    var token, symbol, value;\n    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      value = undefined;\n      token = tokens[i];\n      symbol = token[0];\n\n      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);\n      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);\n      else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);\n      else if (symbol === '&') value = this.unescapedValue(token, context);\n      else if (symbol === 'name') value = this.escapedValue(token, context);\n      else if (symbol === 'text') value = this.rawValue(token);\n\n      if (value !== undefined)\n        buffer += value;\n    }\n\n    return buffer;\n  };\n\n  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {\n    var self = this;\n    var buffer = '';\n    var value = context.lookup(token[1]);\n\n    // This function is used to render an arbitrary template\n    // in the current context by higher-order sections.\n    function subRender (template) {\n      return self.render(template, context, partials);\n    }\n\n    if (!value) return;\n\n    if (isArray(value)) {\n      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);\n      }\n    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);\n    } else if (isFunction(value)) {\n      if (typeof originalTemplate !== 'string')\n        throw new Error('Cannot use higher-order sections without the original template');\n\n      // Extract the portion of the original template that the section contains.\n      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n      if (value != null)\n        buffer += value;\n    } else {\n      buffer += this.renderTokens(token[4], context, partials, originalTemplate);\n    }\n    return buffer;\n  };\n\n  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {\n    var value = context.lookup(token[1]);\n\n    // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n    if (!value || (isArray(value) && value.length === 0))\n      return this.renderTokens(token[4], context, partials, originalTemplate);\n  };\n\n  Writer.prototype.renderPartial = function renderPartial (token, context, partials) {\n    if (!partials) return;\n\n    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n    if (value != null)\n      return this.renderTokens(this.parse(value), context, partials, value);\n  };\n\n  Writer.prototype.unescapedValue = function unescapedValue (token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null)\n      return value;\n  };\n\n  Writer.prototype.escapedValue = function escapedValue (token, context) {\n    var value = context.lookup(token[1]);\n    if (value != null)\n      return mustache.escape(value);\n  };\n\n  Writer.prototype.rawValue = function rawValue (token) {\n    return token[1];\n  };\n\n  mustache.name = 'mustache.js';\n  mustache.version = '2.3.0';\n  mustache.tags = [ '{{', '}}' ];\n\n  // All high-level mustache.* functions use this writer.\n  var defaultWriter = new Writer();\n\n  /**\n   * Clears all cached templates in the default writer.\n   */\n  mustache.clearCache = function clearCache () {\n    return defaultWriter.clearCache();\n  };\n\n  /**\n   * Parses and caches the given template in the default writer and returns the\n   * array of tokens it contains. Doing this ahead of time avoids the need to\n   * parse templates on the fly as they are rendered.\n   */\n  mustache.parse = function parse (template, tags) {\n    return defaultWriter.parse(template, tags);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n  mustache.render = function render (template, view, partials) {\n    if (typeof template !== 'string') {\n      throw new TypeError('Invalid template! Template should be a \"string\" ' +\n                          'but \"' + typeStr(template) + '\" was given as the first ' +\n                          'argument for mustache#render(template, view, partials)');\n    }\n\n    return defaultWriter.render(template, view, partials);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.,\n  /*eslint-disable */ // eslint wants camel cased function name\n  mustache.to_html = function to_html (template, view, partials, send) {\n    /*eslint-enable*/\n\n    var result = mustache.render(template, view, partials);\n\n    if (isFunction(send)) {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  mustache.escape = escapeHtml;\n\n  // Export these mainly for testing, but also for advanced usage.\n  mustache.Scanner = Scanner;\n  mustache.Context = Context;\n  mustache.Writer = Writer;\n\n  return mustache;\n}));\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L211c3RhY2hlL211c3RhY2hlLmpzPzY2ZTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsR0FBRztBQUNILHNZQUFpQztBQUNqQyxHQUFHO0FBQ0g7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsdUJBQXVCLG9CQUFvQixLQUFLO0FBQ2hELHlCQUF5Qjs7QUFFekI7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxxQkFBcUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTyx3Q0FBd0M7QUFDL0M7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLGVBQWU7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLGVBQWU7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsZUFBZTtBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIG11c3RhY2hlLmpzIC0gTG9naWMtbGVzcyB7e211c3RhY2hlfX0gdGVtcGxhdGVzIHdpdGggSmF2YVNjcmlwdFxuICogaHR0cDovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qc1xuICovXG5cbi8qZ2xvYmFsIGRlZmluZTogZmFsc2UgTXVzdGFjaGU6IHRydWUqL1xuXG4oZnVuY3Rpb24gZGVmaW5lTXVzdGFjaGUgKGdsb2JhbCwgZmFjdG9yeSkge1xuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgdHlwZW9mIGV4cG9ydHMubm9kZU5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgZmFjdG9yeShleHBvcnRzKTsgLy8gQ29tbW9uSlNcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpOyAvLyBBTURcbiAgfSBlbHNlIHtcbiAgICBnbG9iYWwuTXVzdGFjaGUgPSB7fTtcbiAgICBmYWN0b3J5KGdsb2JhbC5NdXN0YWNoZSk7IC8vIHNjcmlwdCwgd3NoLCBhc3BcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiBtdXN0YWNoZUZhY3RvcnkgKG11c3RhY2hlKSB7XG5cbiAgdmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXlQb2x5ZmlsbCAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3JlIGNvcnJlY3QgdHlwZW9mIHN0cmluZyBoYW5kbGluZyBhcnJheVxuICAgKiB3aGljaCBub3JtYWxseSByZXR1cm5zIHR5cGVvZiAnb2JqZWN0J1xuICAgKi9cbiAgZnVuY3Rpb24gdHlwZVN0ciAob2JqKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkob2JqKSA/ICdhcnJheScgOiB0eXBlb2Ygb2JqO1xuICB9XG5cbiAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwIChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4gIH1cblxuICAvKipcbiAgICogTnVsbCBzYWZlIHdheSBvZiBjaGVja2luZyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QsXG4gICAqIGluY2x1ZGluZyBpdHMgcHJvdG90eXBlLCBoYXMgYSBnaXZlbiBwcm9wZXJ0eVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzUHJvcGVydHkgKG9iaiwgcHJvcE5hbWUpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgKHByb3BOYW1lIGluIG9iaik7XG4gIH1cblxuICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2lzc3Vlcy5hcGFjaGUub3JnL2ppcmEvYnJvd3NlL0NPVUNIREItNTc3XG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFubC9tdXN0YWNoZS5qcy9pc3N1ZXMvMTg5XG4gIHZhciByZWdFeHBUZXN0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0O1xuICBmdW5jdGlvbiB0ZXN0UmVnRXhwIChyZSwgc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlZ0V4cFRlc3QuY2FsbChyZSwgc3RyaW5nKTtcbiAgfVxuXG4gIHZhciBub25TcGFjZVJlID0gL1xcUy87XG4gIGZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAoc3RyaW5nKSB7XG4gICAgcmV0dXJuICF0ZXN0UmVnRXhwKG5vblNwYWNlUmUsIHN0cmluZyk7XG4gIH1cblxuICB2YXIgZW50aXR5TWFwID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7JyxcbiAgICAnLyc6ICcmI3gyRjsnLFxuICAgICdgJzogJyYjeDYwOycsXG4gICAgJz0nOiAnJiN4M0Q7J1xuICB9O1xuXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWwgKHN0cmluZykge1xuICAgIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKC9bJjw+XCInYD1cXC9dL2csIGZ1bmN0aW9uIGZyb21FbnRpdHlNYXAgKHMpIHtcbiAgICAgIHJldHVybiBlbnRpdHlNYXBbc107XG4gICAgfSk7XG4gIH1cblxuICB2YXIgd2hpdGVSZSA9IC9cXHMqLztcbiAgdmFyIHNwYWNlUmUgPSAvXFxzKy87XG4gIHZhciBlcXVhbHNSZSA9IC9cXHMqPS87XG4gIHZhciBjdXJseVJlID0gL1xccypcXH0vO1xuICB2YXIgdGFnUmUgPSAvI3xcXF58XFwvfD58XFx7fCZ8PXwhLztcblxuICAvKipcbiAgICogQnJlYWtzIHVwIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHN0cmluZyBpbnRvIGEgdHJlZSBvZiB0b2tlbnMuIElmIHRoZSBgdGFnc2BcbiAgICogYXJndW1lbnQgaXMgZ2l2ZW4gaGVyZSBpdCBtdXN0IGJlIGFuIGFycmF5IHdpdGggdHdvIHN0cmluZyB2YWx1ZXM6IHRoZVxuICAgKiBvcGVuaW5nIGFuZCBjbG9zaW5nIHRhZ3MgdXNlZCBpbiB0aGUgdGVtcGxhdGUgKGUuZy4gWyBcIjwlXCIsIFwiJT5cIiBdKS4gT2ZcbiAgICogY291cnNlLCB0aGUgZGVmYXVsdCBpcyB0byB1c2UgbXVzdGFjaGVzIChpLmUuIG11c3RhY2hlLnRhZ3MpLlxuICAgKlxuICAgKiBBIHRva2VuIGlzIGFuIGFycmF5IHdpdGggYXQgbGVhc3QgNCBlbGVtZW50cy4gVGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlXG4gICAqIG11c3RhY2hlIHN5bWJvbCB0aGF0IHdhcyB1c2VkIGluc2lkZSB0aGUgdGFnLCBlLmcuIFwiI1wiIG9yIFwiJlwiLiBJZiB0aGUgdGFnXG4gICAqIGRpZCBub3QgY29udGFpbiBhIHN5bWJvbCAoaS5lLiB7e215VmFsdWV9fSkgdGhpcyBlbGVtZW50IGlzIFwibmFtZVwiLiBGb3JcbiAgICogYWxsIHRleHQgdGhhdCBhcHBlYXJzIG91dHNpZGUgYSBzeW1ib2wgdGhpcyBlbGVtZW50IGlzIFwidGV4dFwiLlxuICAgKlxuICAgKiBUaGUgc2Vjb25kIGVsZW1lbnQgb2YgYSB0b2tlbiBpcyBpdHMgXCJ2YWx1ZVwiLiBGb3IgbXVzdGFjaGUgdGFncyB0aGlzIGlzXG4gICAqIHdoYXRldmVyIGVsc2Ugd2FzIGluc2lkZSB0aGUgdGFnIGJlc2lkZXMgdGhlIG9wZW5pbmcgc3ltYm9sLiBGb3IgdGV4dCB0b2tlbnNcbiAgICogdGhpcyBpcyB0aGUgdGV4dCBpdHNlbGYuXG4gICAqXG4gICAqIFRoZSB0aGlyZCBhbmQgZm91cnRoIGVsZW1lbnRzIG9mIHRoZSB0b2tlbiBhcmUgdGhlIHN0YXJ0IGFuZCBlbmQgaW5kaWNlcyxcbiAgICogcmVzcGVjdGl2ZWx5LCBvZiB0aGUgdG9rZW4gaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlLlxuICAgKlxuICAgKiBUb2tlbnMgdGhhdCBhcmUgdGhlIHJvb3Qgbm9kZSBvZiBhIHN1YnRyZWUgY29udGFpbiB0d28gbW9yZSBlbGVtZW50czogMSkgYW5cbiAgICogYXJyYXkgb2YgdG9rZW5zIGluIHRoZSBzdWJ0cmVlIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsIHRlbXBsYXRlIGF0XG4gICAqIHdoaWNoIHRoZSBjbG9zaW5nIHRhZyBmb3IgdGhhdCBzZWN0aW9uIGJlZ2lucy5cbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlVGVtcGxhdGUgKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgaWYgKCF0ZW1wbGF0ZSlcbiAgICAgIHJldHVybiBbXTtcblxuICAgIHZhciBzZWN0aW9ucyA9IFtdOyAgICAgLy8gU3RhY2sgdG8gaG9sZCBzZWN0aW9uIHRva2Vuc1xuICAgIHZhciB0b2tlbnMgPSBbXTsgICAgICAgLy8gQnVmZmVyIHRvIGhvbGQgdGhlIHRva2Vuc1xuICAgIHZhciBzcGFjZXMgPSBbXTsgICAgICAgLy8gSW5kaWNlcyBvZiB3aGl0ZXNwYWNlIHRva2VucyBvbiB0aGUgY3VycmVudCBsaW5lXG4gICAgdmFyIGhhc1RhZyA9IGZhbHNlOyAgICAvLyBJcyB0aGVyZSBhIHt7dGFnfX0gb24gdGhlIGN1cnJlbnQgbGluZT9cbiAgICB2YXIgbm9uU3BhY2UgPSBmYWxzZTsgIC8vIElzIHRoZXJlIGEgbm9uLXNwYWNlIGNoYXIgb24gdGhlIGN1cnJlbnQgbGluZT9cblxuICAgIC8vIFN0cmlwcyBhbGwgd2hpdGVzcGFjZSB0b2tlbnMgYXJyYXkgZm9yIHRoZSBjdXJyZW50IGxpbmVcbiAgICAvLyBpZiB0aGVyZSB3YXMgYSB7eyN0YWd9fSBvbiBpdCBhbmQgb3RoZXJ3aXNlIG9ubHkgc3BhY2UuXG4gICAgZnVuY3Rpb24gc3RyaXBTcGFjZSAoKSB7XG4gICAgICBpZiAoaGFzVGFnICYmICFub25TcGFjZSkge1xuICAgICAgICB3aGlsZSAoc3BhY2VzLmxlbmd0aClcbiAgICAgICAgICBkZWxldGUgdG9rZW5zW3NwYWNlcy5wb3AoKV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGFjZXMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaGFzVGFnID0gZmFsc2U7XG4gICAgICBub25TcGFjZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBvcGVuaW5nVGFnUmUsIGNsb3NpbmdUYWdSZSwgY2xvc2luZ0N1cmx5UmU7XG4gICAgZnVuY3Rpb24gY29tcGlsZVRhZ3MgKHRhZ3NUb0NvbXBpbGUpIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnc1RvQ29tcGlsZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHRhZ3NUb0NvbXBpbGUgPSB0YWdzVG9Db21waWxlLnNwbGl0KHNwYWNlUmUsIDIpO1xuXG4gICAgICBpZiAoIWlzQXJyYXkodGFnc1RvQ29tcGlsZSkgfHwgdGFnc1RvQ29tcGlsZS5sZW5ndGggIT09IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YWdzOiAnICsgdGFnc1RvQ29tcGlsZSk7XG5cbiAgICAgIG9wZW5pbmdUYWdSZSA9IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHRhZ3NUb0NvbXBpbGVbMF0pICsgJ1xcXFxzKicpO1xuICAgICAgY2xvc2luZ1RhZ1JlID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyArIGVzY2FwZVJlZ0V4cCh0YWdzVG9Db21waWxlWzFdKSk7XG4gICAgICBjbG9zaW5nQ3VybHlSZSA9IG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBlc2NhcGVSZWdFeHAoJ30nICsgdGFnc1RvQ29tcGlsZVsxXSkpO1xuICAgIH1cblxuICAgIGNvbXBpbGVUYWdzKHRhZ3MgfHwgbXVzdGFjaGUudGFncyk7XG5cbiAgICB2YXIgc2Nhbm5lciA9IG5ldyBTY2FubmVyKHRlbXBsYXRlKTtcblxuICAgIHZhciBzdGFydCwgdHlwZSwgdmFsdWUsIGNociwgdG9rZW4sIG9wZW5TZWN0aW9uO1xuICAgIHdoaWxlICghc2Nhbm5lci5lb3MoKSkge1xuICAgICAgc3RhcnQgPSBzY2FubmVyLnBvcztcblxuICAgICAgLy8gTWF0Y2ggYW55IHRleHQgYmV0d2VlbiB0YWdzLlxuICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChvcGVuaW5nVGFnUmUpO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpIDwgdmFsdWVMZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNociA9IHZhbHVlLmNoYXJBdChpKTtcblxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoY2hyKSkge1xuICAgICAgICAgICAgc3BhY2VzLnB1c2godG9rZW5zLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b2tlbnMucHVzaChbICd0ZXh0JywgY2hyLCBzdGFydCwgc3RhcnQgKyAxIF0pO1xuICAgICAgICAgIHN0YXJ0ICs9IDE7XG5cbiAgICAgICAgICAvLyBDaGVjayBmb3Igd2hpdGVzcGFjZSBvbiB0aGUgY3VycmVudCBsaW5lLlxuICAgICAgICAgIGlmIChjaHIgPT09ICdcXG4nKVxuICAgICAgICAgICAgc3RyaXBTcGFjZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1hdGNoIHRoZSBvcGVuaW5nIHRhZy5cbiAgICAgIGlmICghc2Nhbm5lci5zY2FuKG9wZW5pbmdUYWdSZSkpXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBoYXNUYWcgPSB0cnVlO1xuXG4gICAgICAvLyBHZXQgdGhlIHRhZyB0eXBlLlxuICAgICAgdHlwZSA9IHNjYW5uZXIuc2Nhbih0YWdSZSkgfHwgJ25hbWUnO1xuICAgICAgc2Nhbm5lci5zY2FuKHdoaXRlUmUpO1xuXG4gICAgICAvLyBHZXQgdGhlIHRhZyB2YWx1ZS5cbiAgICAgIGlmICh0eXBlID09PSAnPScpIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChlcXVhbHNSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhbihlcXVhbHNSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdUYWdSZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd7Jykge1xuICAgICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKGNsb3NpbmdDdXJseVJlKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuKGN1cmx5UmUpO1xuICAgICAgICBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgICB0eXBlID0gJyYnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXRjaCB0aGUgY2xvc2luZyB0YWcuXG4gICAgICBpZiAoIXNjYW5uZXIuc2NhbihjbG9zaW5nVGFnUmUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHRhZyBhdCAnICsgc2Nhbm5lci5wb3MpO1xuXG4gICAgICB0b2tlbiA9IFsgdHlwZSwgdmFsdWUsIHN0YXJ0LCBzY2FubmVyLnBvcyBdO1xuICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuXG4gICAgICBpZiAodHlwZSA9PT0gJyMnIHx8IHR5cGUgPT09ICdeJykge1xuICAgICAgICBzZWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJy8nKSB7XG4gICAgICAgIC8vIENoZWNrIHNlY3Rpb24gbmVzdGluZy5cbiAgICAgICAgb3BlblNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcblxuICAgICAgICBpZiAoIW9wZW5TZWN0aW9uKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5vcGVuZWQgc2VjdGlvbiBcIicgKyB2YWx1ZSArICdcIiBhdCAnICsgc3RhcnQpO1xuXG4gICAgICAgIGlmIChvcGVuU2VjdGlvblsxXSAhPT0gdmFsdWUpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCBzZWN0aW9uIFwiJyArIG9wZW5TZWN0aW9uWzFdICsgJ1wiIGF0ICcgKyBzdGFydCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICduYW1lJyB8fCB0eXBlID09PSAneycgfHwgdHlwZSA9PT0gJyYnKSB7XG4gICAgICAgIG5vblNwYWNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJz0nKSB7XG4gICAgICAgIC8vIFNldCB0aGUgdGFncyBmb3IgdGhlIG5leHQgdGltZSBhcm91bmQuXG4gICAgICAgIGNvbXBpbGVUYWdzKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgYXJlIG5vIG9wZW4gc2VjdGlvbnMgd2hlbiB3ZSdyZSBkb25lLlxuICAgIG9wZW5TZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG5cbiAgICBpZiAob3BlblNlY3Rpb24pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuY2xvc2VkIHNlY3Rpb24gXCInICsgb3BlblNlY3Rpb25bMV0gKyAnXCIgYXQgJyArIHNjYW5uZXIucG9zKTtcblxuICAgIHJldHVybiBuZXN0VG9rZW5zKHNxdWFzaFRva2Vucyh0b2tlbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lcyB0aGUgdmFsdWVzIG9mIGNvbnNlY3V0aXZlIHRleHQgdG9rZW5zIGluIHRoZSBnaXZlbiBgdG9rZW5zYCBhcnJheVxuICAgKiB0byBhIHNpbmdsZSB0b2tlbi5cbiAgICovXG4gIGZ1bmN0aW9uIHNxdWFzaFRva2VucyAodG9rZW5zKSB7XG4gICAgdmFyIHNxdWFzaGVkVG9rZW5zID0gW107XG5cbiAgICB2YXIgdG9rZW4sIGxhc3RUb2tlbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlblswXSA9PT0gJ3RleHQnICYmIGxhc3RUb2tlbiAmJiBsYXN0VG9rZW5bMF0gPT09ICd0ZXh0Jykge1xuICAgICAgICAgIGxhc3RUb2tlblsxXSArPSB0b2tlblsxXTtcbiAgICAgICAgICBsYXN0VG9rZW5bM10gPSB0b2tlblszXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcXVhc2hlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzcXVhc2hlZFRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtcyB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHRva2Vuc2AgaW50byBhIG5lc3RlZCB0cmVlIHN0cnVjdHVyZSB3aGVyZVxuICAgKiB0b2tlbnMgdGhhdCByZXByZXNlbnQgYSBzZWN0aW9uIGhhdmUgdHdvIGFkZGl0aW9uYWwgaXRlbXM6IDEpIGFuIGFycmF5IG9mXG4gICAqIGFsbCB0b2tlbnMgdGhhdCBhcHBlYXIgaW4gdGhhdCBzZWN0aW9uIGFuZCAyKSB0aGUgaW5kZXggaW4gdGhlIG9yaWdpbmFsXG4gICAqIHRlbXBsYXRlIHRoYXQgcmVwcmVzZW50cyB0aGUgZW5kIG9mIHRoYXQgc2VjdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIG5lc3RUb2tlbnMgKHRva2Vucykge1xuICAgIHZhciBuZXN0ZWRUb2tlbnMgPSBbXTtcbiAgICB2YXIgY29sbGVjdG9yID0gbmVzdGVkVG9rZW5zO1xuICAgIHZhciBzZWN0aW9ucyA9IFtdO1xuXG4gICAgdmFyIHRva2VuLCBzZWN0aW9uO1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICAgIGNhc2UgJyMnOlxuICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICBjb2xsZWN0b3IucHVzaCh0b2tlbik7XG4gICAgICAgICAgc2VjdGlvbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29sbGVjdG9yID0gdG9rZW5bNF0gPSBbXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgc2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuICAgICAgICAgIHNlY3Rpb25bNV0gPSB0b2tlblsyXTtcbiAgICAgICAgICBjb2xsZWN0b3IgPSBzZWN0aW9ucy5sZW5ndGggPiAwID8gc2VjdGlvbnNbc2VjdGlvbnMubGVuZ3RoIC0gMV1bNF0gOiBuZXN0ZWRUb2tlbnM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29sbGVjdG9yLnB1c2godG9rZW4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXN0ZWRUb2tlbnM7XG4gIH1cblxuICAvKipcbiAgICogQSBzaW1wbGUgc3RyaW5nIHNjYW5uZXIgdGhhdCBpcyB1c2VkIGJ5IHRoZSB0ZW1wbGF0ZSBwYXJzZXIgdG8gZmluZFxuICAgKiB0b2tlbnMgaW4gdGVtcGxhdGUgc3RyaW5ncy5cbiAgICovXG4gIGZ1bmN0aW9uIFNjYW5uZXIgKHN0cmluZykge1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIHRoaXMudGFpbCA9IHN0cmluZztcbiAgICB0aGlzLnBvcyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRhaWwgaXMgZW1wdHkgKGVuZCBvZiBzdHJpbmcpLlxuICAgKi9cbiAgU2Nhbm5lci5wcm90b3R5cGUuZW9zID0gZnVuY3Rpb24gZW9zICgpIHtcbiAgICByZXR1cm4gdGhpcy50YWlsID09PSAnJztcbiAgfTtcblxuICAvKipcbiAgICogVHJpZXMgdG8gbWF0Y2ggdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBhdCB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICogUmV0dXJucyB0aGUgbWF0Y2hlZCB0ZXh0IGlmIGl0IGNhbiBtYXRjaCwgdGhlIGVtcHR5IHN0cmluZyBvdGhlcndpc2UuXG4gICAqL1xuICBTY2FubmVyLnByb3RvdHlwZS5zY2FuID0gZnVuY3Rpb24gc2NhbiAocmUpIHtcbiAgICB2YXIgbWF0Y2ggPSB0aGlzLnRhaWwubWF0Y2gocmUpO1xuXG4gICAgaWYgKCFtYXRjaCB8fCBtYXRjaC5pbmRleCAhPT0gMClcbiAgICAgIHJldHVybiAnJztcblxuICAgIHZhciBzdHJpbmcgPSBtYXRjaFswXTtcblxuICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoc3RyaW5nLmxlbmd0aCk7XG4gICAgdGhpcy5wb3MgKz0gc3RyaW5nLmxlbmd0aDtcblxuICAgIHJldHVybiBzdHJpbmc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNraXBzIGFsbCB0ZXh0IHVudGlsIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gY2FuIGJlIG1hdGNoZWQuIFJldHVybnNcbiAgICogdGhlIHNraXBwZWQgc3RyaW5nLCB3aGljaCBpcyB0aGUgZW50aXJlIHRhaWwgaWYgbm8gbWF0Y2ggY2FuIGJlIG1hZGUuXG4gICAqL1xuICBTY2FubmVyLnByb3RvdHlwZS5zY2FuVW50aWwgPSBmdW5jdGlvbiBzY2FuVW50aWwgKHJlKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy50YWlsLnNlYXJjaChyZSksIG1hdGNoO1xuXG4gICAgc3dpdGNoIChpbmRleCkge1xuICAgICAgY2FzZSAtMTpcbiAgICAgICAgbWF0Y2ggPSB0aGlzLnRhaWw7XG4gICAgICAgIHRoaXMudGFpbCA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgbWF0Y2ggPSAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBtYXRjaCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwuc3Vic3RyaW5nKGluZGV4KTtcbiAgICB9XG5cbiAgICB0aGlzLnBvcyArPSBtYXRjaC5sZW5ndGg7XG5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSByZW5kZXJpbmcgY29udGV4dCBieSB3cmFwcGluZyBhIHZpZXcgb2JqZWN0IGFuZFxuICAgKiBtYWludGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IGNvbnRleHQuXG4gICAqL1xuICBmdW5jdGlvbiBDb250ZXh0ICh2aWV3LCBwYXJlbnRDb250ZXh0KSB7XG4gICAgdGhpcy52aWV3ID0gdmlldztcbiAgICB0aGlzLmNhY2hlID0geyAnLic6IHRoaXMudmlldyB9O1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50Q29udGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNvbnRleHQgdXNpbmcgdGhlIGdpdmVuIHZpZXcgd2l0aCB0aGlzIGNvbnRleHRcbiAgICogYXMgdGhlIHBhcmVudC5cbiAgICovXG4gIENvbnRleHQucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoICh2aWV3KSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZXh0KHZpZXcsIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGlzIGNvbnRleHQsIHRyYXZlcnNpbmdcbiAgICogdXAgdGhlIGNvbnRleHQgaGllcmFyY2h5IGlmIHRoZSB2YWx1ZSBpcyBhYnNlbnQgaW4gdGhpcyBjb250ZXh0J3Mgdmlldy5cbiAgICovXG4gIENvbnRleHQucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIGxvb2t1cCAobmFtZSkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cbiAgICB2YXIgdmFsdWU7XG4gICAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICB2YWx1ZSA9IGNhY2hlW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMsIG5hbWVzLCBpbmRleCwgbG9va3VwSGl0ID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChjb250ZXh0KSB7XG4gICAgICAgIGlmIChuYW1lLmluZGV4T2YoJy4nKSA+IDApIHtcbiAgICAgICAgICB2YWx1ZSA9IGNvbnRleHQudmlldztcbiAgICAgICAgICBuYW1lcyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICBpbmRleCA9IDA7XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBVc2luZyB0aGUgZG90IG5vdGlvbiBwYXRoIGluIGBuYW1lYCwgd2UgZGVzY2VuZCB0aHJvdWdoIHRoZVxuICAgICAgICAgICAqIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVG8gYmUgY2VydGFpbiB0aGF0IHRoZSBsb29rdXAgaGFzIGJlZW4gc3VjY2Vzc2Z1bCwgd2UgaGF2ZSB0b1xuICAgICAgICAgICAqIGNoZWNrIGlmIHRoZSBsYXN0IG9iamVjdCBpbiB0aGUgcGF0aCBhY3R1YWxseSBoYXMgdGhlIHByb3BlcnR5XG4gICAgICAgICAgICogd2UgYXJlIGxvb2tpbmcgZm9yLiBXZSBzdG9yZSB0aGUgcmVzdWx0IGluIGBsb29rdXBIaXRgLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVGhpcyBpcyBzcGVjaWFsbHkgbmVjZXNzYXJ5IGZvciB3aGVuIHRoZSB2YWx1ZSBoYXMgYmVlbiBzZXQgdG9cbiAgICAgICAgICAgKiBgdW5kZWZpbmVkYCBhbmQgd2Ugd2FudCB0byBhdm9pZCBsb29raW5nIHVwIHBhcmVudCBjb250ZXh0cy5cbiAgICAgICAgICAgKiovXG4gICAgICAgICAgd2hpbGUgKHZhbHVlICE9IG51bGwgJiYgaW5kZXggPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbmFtZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgbG9va3VwSGl0ID0gaGFzUHJvcGVydHkodmFsdWUsIG5hbWVzW2luZGV4XSk7XG5cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbbmFtZXNbaW5kZXgrK11dO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGNvbnRleHQudmlld1tuYW1lXTtcbiAgICAgICAgICBsb29rdXBIaXQgPSBoYXNQcm9wZXJ0eShjb250ZXh0LnZpZXcsIG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvb2t1cEhpdClcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKVxuICAgICAgdmFsdWUgPSB2YWx1ZS5jYWxsKHRoaXMudmlldyk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgV3JpdGVyIGtub3dzIGhvdyB0byB0YWtlIGEgc3RyZWFtIG9mIHRva2VucyBhbmQgcmVuZGVyIHRoZW0gdG8gYVxuICAgKiBzdHJpbmcsIGdpdmVuIGEgY29udGV4dC4gSXQgYWxzbyBtYWludGFpbnMgYSBjYWNoZSBvZiB0ZW1wbGF0ZXMgdG9cbiAgICogYXZvaWQgdGhlIG5lZWQgdG8gcGFyc2UgdGhlIHNhbWUgdGVtcGxhdGUgdHdpY2UuXG4gICAqL1xuICBmdW5jdGlvbiBXcml0ZXIgKCkge1xuICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhpcyB3cml0ZXIuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlICgpIHtcbiAgICB0aGlzLmNhY2hlID0ge307XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbmQgY2FjaGVzIHRoZSBnaXZlbiBgdGVtcGxhdGVgIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiB0b2tlbnNcbiAgICogdGhhdCBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgcGFyc2UuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcbiAgICB2YXIgdG9rZW5zID0gY2FjaGVbdGVtcGxhdGVdO1xuXG4gICAgaWYgKHRva2VucyA9PSBudWxsKVxuICAgICAgdG9rZW5zID0gY2FjaGVbdGVtcGxhdGVdID0gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgdGFncyk7XG5cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWdoLWxldmVsIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHdpdGhcbiAgICogdGhlIGdpdmVuIGB2aWV3YC5cbiAgICpcbiAgICogVGhlIG9wdGlvbmFsIGBwYXJ0aWFsc2AgYXJndW1lbnQgbWF5IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgKiBuYW1lcyBhbmQgdGVtcGxhdGVzIG9mIHBhcnRpYWxzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRlbXBsYXRlLiBJdCBtYXlcbiAgICogYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBsb2FkIHBhcnRpYWwgdGVtcGxhdGVzIG9uIHRoZSBmbHlcbiAgICogdGhhdCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudDogdGhlIG5hbWUgb2YgdGhlIHBhcnRpYWwuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKSB7XG4gICAgdmFyIHRva2VucyA9IHRoaXMucGFyc2UodGVtcGxhdGUpO1xuICAgIHZhciBjb250ZXh0ID0gKHZpZXcgaW5zdGFuY2VvZiBDb250ZXh0KSA/IHZpZXcgOiBuZXcgQ29udGV4dCh2aWV3KTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5zLCBjb250ZXh0LCBwYXJ0aWFscywgdGVtcGxhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb3ctbGV2ZWwgbWV0aG9kIHRoYXQgcmVuZGVycyB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHRva2Vuc2AgdXNpbmdcbiAgICogdGhlIGdpdmVuIGBjb250ZXh0YCBhbmQgYHBhcnRpYWxzYC5cbiAgICpcbiAgICogTm90ZTogVGhlIGBvcmlnaW5hbFRlbXBsYXRlYCBpcyBvbmx5IGV2ZXIgdXNlZCB0byBleHRyYWN0IHRoZSBwb3J0aW9uXG4gICAqIG9mIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSB0aGF0IHdhcyBjb250YWluZWQgaW4gYSBoaWdoZXItb3JkZXIgc2VjdGlvbi5cbiAgICogSWYgdGhlIHRlbXBsYXRlIGRvZXNuJ3QgdXNlIGhpZ2hlci1vcmRlciBzZWN0aW9ucywgdGhpcyBhcmd1bWVudCBtYXlcbiAgICogYmUgb21pdHRlZC5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyVG9rZW5zID0gZnVuY3Rpb24gcmVuZGVyVG9rZW5zICh0b2tlbnMsIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKSB7XG4gICAgdmFyIGJ1ZmZlciA9ICcnO1xuXG4gICAgdmFyIHRva2VuLCBzeW1ib2wsIHZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICBzeW1ib2wgPSB0b2tlblswXTtcblxuICAgICAgaWYgKHN5bWJvbCA9PT0gJyMnKSB2YWx1ZSA9IHRoaXMucmVuZGVyU2VjdGlvbih0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnXicpIHZhbHVlID0gdGhpcy5yZW5kZXJJbnZlcnRlZCh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnPicpIHZhbHVlID0gdGhpcy5yZW5kZXJQYXJ0aWFsKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICcmJykgdmFsdWUgPSB0aGlzLnVuZXNjYXBlZFZhbHVlKHRva2VuLCBjb250ZXh0KTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ25hbWUnKSB2YWx1ZSA9IHRoaXMuZXNjYXBlZFZhbHVlKHRva2VuLCBjb250ZXh0KTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ3RleHQnKSB2YWx1ZSA9IHRoaXMucmF3VmFsdWUodG9rZW4pO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgYnVmZmVyICs9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmZXI7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJTZWN0aW9uID0gZnVuY3Rpb24gcmVuZGVyU2VjdGlvbiAodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBidWZmZXIgPSAnJztcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmVuZGVyIGFuIGFyYml0cmFyeSB0ZW1wbGF0ZVxuICAgIC8vIGluIHRoZSBjdXJyZW50IGNvbnRleHQgYnkgaGlnaGVyLW9yZGVyIHNlY3Rpb25zLlxuICAgIGZ1bmN0aW9uIHN1YlJlbmRlciAodGVtcGxhdGUpIHtcbiAgICAgIHJldHVybiBzZWxmLnJlbmRlcih0ZW1wbGF0ZSwgY29udGV4dCwgcGFydGlhbHMpO1xuICAgIH1cblxuICAgIGlmICghdmFsdWUpIHJldHVybjtcblxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yICh2YXIgaiA9IDAsIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBqIDwgdmFsdWVMZW5ndGg7ICsraikge1xuICAgICAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQucHVzaCh2YWx1ZVtqXSksIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQucHVzaCh2YWx1ZSksIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICBpZiAodHlwZW9mIG9yaWdpbmFsVGVtcGxhdGUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgaGlnaGVyLW9yZGVyIHNlY3Rpb25zIHdpdGhvdXQgdGhlIG9yaWdpbmFsIHRlbXBsYXRlJyk7XG5cbiAgICAgIC8vIEV4dHJhY3QgdGhlIHBvcnRpb24gb2YgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRoYXQgdGhlIHNlY3Rpb24gY29udGFpbnMuXG4gICAgICB2YWx1ZSA9IHZhbHVlLmNhbGwoY29udGV4dC52aWV3LCBvcmlnaW5hbFRlbXBsYXRlLnNsaWNlKHRva2VuWzNdLCB0b2tlbls1XSksIHN1YlJlbmRlcik7XG5cbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgICBidWZmZXIgKz0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVySW52ZXJ0ZWQgPSBmdW5jdGlvbiByZW5kZXJJbnZlcnRlZCAodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuXG4gICAgLy8gVXNlIEphdmFTY3JpcHQncyBkZWZpbml0aW9uIG9mIGZhbHN5LiBJbmNsdWRlIGVtcHR5IGFycmF5cy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzE4NlxuICAgIGlmICghdmFsdWUgfHwgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkpXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlclBhcnRpYWwgPSBmdW5jdGlvbiByZW5kZXJQYXJ0aWFsICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMpIHtcbiAgICBpZiAoIXBhcnRpYWxzKSByZXR1cm47XG5cbiAgICB2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKHBhcnRpYWxzKSA/IHBhcnRpYWxzKHRva2VuWzFdKSA6IHBhcnRpYWxzW3Rva2VuWzFdXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0aGlzLnBhcnNlKHZhbHVlKSwgY29udGV4dCwgcGFydGlhbHMsIHZhbHVlKTtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnVuZXNjYXBlZFZhbHVlID0gZnVuY3Rpb24gdW5lc2NhcGVkVmFsdWUgKHRva2VuLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUuZXNjYXBlZFZhbHVlID0gZnVuY3Rpb24gZXNjYXBlZFZhbHVlICh0b2tlbiwgY29udGV4dCkge1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgIHJldHVybiBtdXN0YWNoZS5lc2NhcGUodmFsdWUpO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmF3VmFsdWUgPSBmdW5jdGlvbiByYXdWYWx1ZSAodG9rZW4pIHtcbiAgICByZXR1cm4gdG9rZW5bMV07XG4gIH07XG5cbiAgbXVzdGFjaGUubmFtZSA9ICdtdXN0YWNoZS5qcyc7XG4gIG11c3RhY2hlLnZlcnNpb24gPSAnMi4zLjAnO1xuICBtdXN0YWNoZS50YWdzID0gWyAne3snLCAnfX0nIF07XG5cbiAgLy8gQWxsIGhpZ2gtbGV2ZWwgbXVzdGFjaGUuKiBmdW5jdGlvbnMgdXNlIHRoaXMgd3JpdGVyLlxuICB2YXIgZGVmYXVsdFdyaXRlciA9IG5ldyBXcml0ZXIoKTtcblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBjYWNoZWQgdGVtcGxhdGVzIGluIHRoZSBkZWZhdWx0IHdyaXRlci5cbiAgICovXG4gIG11c3RhY2hlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlICgpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5jbGVhckNhY2hlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbmQgY2FjaGVzIHRoZSBnaXZlbiB0ZW1wbGF0ZSBpbiB0aGUgZGVmYXVsdCB3cml0ZXIgYW5kIHJldHVybnMgdGhlXG4gICAqIGFycmF5IG9mIHRva2VucyBpdCBjb250YWlucy4gRG9pbmcgdGhpcyBhaGVhZCBvZiB0aW1lIGF2b2lkcyB0aGUgbmVlZCB0b1xuICAgKiBwYXJzZSB0ZW1wbGF0ZXMgb24gdGhlIGZseSBhcyB0aGV5IGFyZSByZW5kZXJlZC5cbiAgICovXG4gIG11c3RhY2hlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRXcml0ZXIucGFyc2UodGVtcGxhdGUsIHRhZ3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBgdGVtcGxhdGVgIHdpdGggdGhlIGdpdmVuIGB2aWV3YCBhbmQgYHBhcnRpYWxzYCB1c2luZyB0aGVcbiAgICogZGVmYXVsdCB3cml0ZXIuXG4gICAqL1xuICBtdXN0YWNoZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscykge1xuICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRlbXBsYXRlISBUZW1wbGF0ZSBzaG91bGQgYmUgYSBcInN0cmluZ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYnV0IFwiJyArIHR5cGVTdHIodGVtcGxhdGUpICsgJ1wiIHdhcyBnaXZlbiBhcyB0aGUgZmlyc3QgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhcmd1bWVudCBmb3IgbXVzdGFjaGUjcmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscyknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5yZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC40LnguLFxuICAvKmVzbGludC1kaXNhYmxlICovIC8vIGVzbGludCB3YW50cyBjYW1lbCBjYXNlZCBmdW5jdGlvbiBuYW1lXG4gIG11c3RhY2hlLnRvX2h0bWwgPSBmdW5jdGlvbiB0b19odG1sICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMsIHNlbmQpIHtcbiAgICAvKmVzbGludC1lbmFibGUqL1xuXG4gICAgdmFyIHJlc3VsdCA9IG11c3RhY2hlLnJlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oc2VuZCkpIHtcbiAgICAgIHNlbmQocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBlc2NhcGluZyBmdW5jdGlvbiBzbyB0aGF0IHRoZSB1c2VyIG1heSBvdmVycmlkZSBpdC5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8yNDRcbiAgbXVzdGFjaGUuZXNjYXBlID0gZXNjYXBlSHRtbDtcblxuICAvLyBFeHBvcnQgdGhlc2UgbWFpbmx5IGZvciB0ZXN0aW5nLCBidXQgYWxzbyBmb3IgYWR2YW5jZWQgdXNhZ2UuXG4gIG11c3RhY2hlLlNjYW5uZXIgPSBTY2FubmVyO1xuICBtdXN0YWNoZS5Db250ZXh0ID0gQ29udGV4dDtcbiAgbXVzdGFjaGUuV3JpdGVyID0gV3JpdGVyO1xuXG4gIHJldHVybiBtdXN0YWNoZTtcbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tdXN0YWNoZS9tdXN0YWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ })
/******/ ])
});
;